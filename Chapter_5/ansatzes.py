'''
Tools for manipulation with ansatzes and Hessian calculations
'''


import numpy as np
import elementaries as el
import itertools

def QSA_paulis(string):
    '''
    Creates a pauli string identifier, corresponding to a QSA YXX string, given the list of positions of paulis in that string.
    '''
    lis=[]
    switch=0
    

    for element in string:

        if switch == 1:
            lis+=[[element,1]]

        if switch == 0:
            lis+=[[element, 2]]
            switch+=1
        

    return(lis)

def k0_subsets(k0):
    '''
    Returns subsets of k0 elements from the ordered list of qubits (from 1 to N)
    '''    

    #some extra massaging performed, so that a list of lists is returned
    
    return(list(map(list,itertools.combinations(list(range(el.number_of_qubits)),k0))))

def k0QSA(k0):
    '''
    Creates a list of pauli string identifiers, corresponding to a k0-quantum subset ansatz. This means that all the QSA gates of order k0 are used. 
    '''    
    
    return(list(map(QSA_paulis, k0_subsets(k0))))

def kQSA(k, reverse=False):
    '''
    Creates a list of pauli string identifiers, corresponding to a k-quantum subset ansatz. This means that all the QSA gates of order smaller or equal to k are used, and its canonical form is sustained.
    '''    
    lis=[]
    for k0 in range(1,k+1):
        lis+=k0_subsets(k0)
    
    #sorting everything according to full-QSA prescription: finding the right reordering
    ind=[]
    
    for element in lis:
        ind+=[element[0]]
    
    if reverse==False:
        ind=np.array(ind).argsort()[::-1]
    else:
        ind=np.array(ind).argsort()

    lis=list(np.array(lis)[ind])
    
    return(list(map(QSA_paulis, lis)))

def customQSA(diagram_list):
    
    lis=diagram_list.copy()
    
    ind=[]
    
    for element in lis:
        ind+=[element[0]]
        
    ind=np.array(ind).argsort()[::-1]
    
    lis=list(np.array(lis)[ind])
    
    return(list(map(QSA_paulis, lis)))
    
    

def ansatz_operator(list_of_strings, list_of_thetas):
    '''
    Returns an ansatz operator at a given value of parameters.
    
    Inputs a list of pauli string identifiers, which defines an ansatz, and ansatz parameter values list_of_thetas.     
    '''
    operator=el.identity
    
    for i in range(len(list_of_strings)):
        operator=el.string_iexp(list_of_strings[i], list_of_thetas[i]).dot(operator)
    
    return(operator)

def ansatz_state(list_of_strings, list_of_thetas, in_state=el.default_state):
    '''
    Returns a quantum state, generated by an ansatz operator at a given value of parameters.
    
    Inputs:
    
    -a list of pauli string identifiers, which defines an ansatz
    -ansatz parameter values list_of_thetas
    -if needed, an initial computational basis state encoded in a bitstring; its complex prefactor
    '''
    
    out_state=in_state
    
    for i in range(len(list_of_strings)):
        out_state=el.string_iexp(list_of_strings[i], list_of_thetas[i]).dot(out_state)
    
    return(out_state)

def theta_derivative_computation(list_of_strings, list_of_thetas, modified_in_state, theta_modification):
    '''
    Calculates a derivative w.r.t. theta_j of some ansatz-generated state. The resulting state is calculated as an action of the same ansatz on a modified initial state, with modified set of thetas (some thetas are inverted, i.e. changed to minus thetas). To generate proper input of initial data, use theta_derivative_preparation.
    
    list list_of_strings - list of string identifiers corresponding to the ansatz
    
    list list_of_thetas - ansatz parameter values 
    
    int list theta_modification - a list that identifies which thetas have to be inverted during the computation
    
    modified_in_state_bitstring, modified_in_state_prefactor - specifications of a modified initial state
    
    '''   
    
    effective_thetas=list( map( lambda x,y: x*(-1)**y, list_of_thetas, theta_modification) )
    
    return(ansatz_state(list_of_strings, effective_thetas, modified_in_state) )


def theta_derivative_preparation(j, list_of_string_ids, in_state=el.default_state, theta_modification=np.array(None)):
    '''
    Prepares necessary information to calculate a derivative w.r.t. theta_j of some ansatz-generated state. The current implementation assumes ansatzes which only have Ys and Xs in their Pauli strings (i.e. QSA's). 
    
    Output:
    
    int list new_theta_modification - a list that identifies which thetas have to be inverted for the computation
  
    new_in_state_bitstring, new_in_state_prefactor - specifications of a modified initial state
    
    Input: 
    
    integer j - the index number of theta
    
    list list_of_strings - list of string identifiers corresponding to the ansatz
    
    int list theta_modification - a list that identifies which thetas, if any, were to be inverted in preparation of an old state
    
    in_state_bitstring, in_state_prefactor - specifications of an initial state

    '''
    if theta_modification.any()==None:
        theta_modification=np.zeros(len(list_of_string_ids), dtype='int')
    
#     In what follows, simply in_state_prefactor*=1j would be wrong, since we may have -i*theta in the exponent, because of previous theta inversions.
#     Without this correction, the matrix of state's second derivatives will not be symmetric. 
    
    new_theta_modification=theta_modification.copy()    

    #checking, which Paulis anticommute and which commute, and noting down which theta's therefore have to be inverted
    
    for i in range(j):
        for pauli in list_of_string_ids[i]:
            for ppauli in list_of_string_ids[j]:
                new_theta_modification[i]=np.mod(new_theta_modification[i]+int((pauli[0]==ppauli[0])&(pauli[1]!=ppauli[1])),2)
    
    list_of_strings=el.list_of_strings(list_of_string_ids)
    
    new_in_state=1j*((-1)**theta_modification[j])*(list_of_strings[j].dot(in_state))
    
    return(new_in_state, new_theta_modification)

def hessian_computation(observable, list_of_strings, list_of_thetas, first_derivatives_prepared, second_derivatives_prepared):
    
    state=ansatz_state(list_of_strings, list_of_thetas)
    
    hessian_computed=[[None for i in range(len(list_of_strings))] for j in range(len(list_of_strings))]
    
    for i in range(len(list_of_strings)):
        for j in range(len(list_of_strings)):
            
            data_i=first_derivatives_prepared[i]
            data_j=first_derivatives_prepared[j]
            data_ij=second_derivatives_prepared[i][j]
            
            state_i=theta_derivative_computation(list_of_strings, list_of_thetas, data_i[0], data_i[1])
            state_j=theta_derivative_computation(list_of_strings, list_of_thetas, data_j[0], data_j[1])
            state_ij=theta_derivative_computation(list_of_strings, list_of_thetas, data_ij[0], data_ij[1])
            
            hess=2*np.real(state_i.dot(observable.dot(state_j))+state.dot(observable.dot(state_ij)))
            hessian_computed[i][j]=hess
        
    return(np.array(hessian_computed))

def jacobian_computation(observable, list_of_strings, list_of_thetas, first_derivatives_prepared):
    
    state=ansatz_state(list_of_strings, list_of_thetas)
    
    jacobian_computed=[None for i in range(len(list_of_strings))]
    
    for i in range(len(list_of_strings)):
        data_i=first_derivatives_prepared[i]
        state_i=theta_derivative_computation(list_of_strings, list_of_thetas, data_i[0], data_i[1])
        jac=np.real(state.dot(observable.dot(state_i))+state_i.dot(observable.dot(state)))
        jacobian_computed[i]=jac
        
    return(np.array(jacobian_computed))

def hessian_preparation(list_of_string_ids, in_state=el.default_state):
    
    first_derivatives=[None for i in range(len(list_of_string_ids))]
    
    for j in range(len(list_of_string_ids)):
        first_derivatives[j]=(theta_derivative_preparation(j, list_of_string_ids, in_state))
    
    second_derivatives=[[None for i in range(len(list_of_string_ids))] for j in range(len(list_of_string_ids))]
    
    for i in range(len(list_of_string_ids)):
        for j in range(len(list_of_string_ids)):
            (inst, tmod)=theta_derivative_preparation(j, list_of_string_ids, in_state)
            second_derivatives[i][j]=theta_derivative_preparation(i, list_of_string_ids, inst, tmod)
    
    
    return(first_derivatives,second_derivatives)


    